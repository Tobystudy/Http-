# 15장 엔터티와 인코딩
Http는 다음을 보장한다.
- 객체는 Content-Type(미디어 포멧), Content-Langeuage 헤더를 이용해 클라이언트는 콘텐츠를 바르게 처리할 수 있다.
- 객체는 Content-Length와 Content-Encoding 헤더를 이용해 올바르게 압축이 풀릴것이다.
- 객체는 엔티티 검사기와 캐시 만료 제어를 통해 항상 최신일 것이다.
- 내용 협상을 위한 Accept관련 헤더에 기반하여 사용자의 요구를 만족할 것이다.
- 범위 요청, 델타 인코딩, 데이터 압축을 이용해 빠르고 효율적으로 네트워크를 이동할 것이다.
- 전송 인코딩 헤더와 Content-MD5체크섬을 이용해 조작되지않고 온전하게 도착할 것이다.

이를 가능케 하기위해 HTTP는 콘텐츠를 나르기위한 잘 라벨링된 엔터티를 사용한다.

이 장에서는 엔터티 및 그와 연관된 엔터티 헤더들과 이 들이 화물을 잘 수송하기위해 어떤 일을 하는지 논의한다.
- HTTP 데이터를 담는 컨테이너, HTTP 메시지 엔터티의 포맷과 동작방식
- HTTP 엔터티의 본문의 크기를 기술하는 방법, 크기측정을 위해 HTTP가 요구하는것
- 클라이언트가 콘텐츠를 바르게 처리할 수 있도록 제공되는 엔터티 헤더들.
- 공간을 적게 차지하고 더 안전하게 만들기위한 콘텐츠 인코딩
- 특정 종류의 콘텐츠 송수신을 개선하기위한 전송 인코딩, 그 중에서도 청크 인코딩
- 클라이언트가 요청한 콘텐츠의 최신 버전을 가져올 수 있도록 도와주는 태그, 라벨, 시간, 체크섬
- 콘텐츠의 버전 번호처럼 동작하는 검사기, 객체를 최신 상태로 유지하기 위해 설계된 HTTP 헤더 필드
- 요청의 중단지점부터 재개하고자 할 때 유용한 범위 요청
- 변경이 있는 부분만 요청할 수 있는 HTTP 델타 인코딩 확장
- 엔터티 콘텐츠가 프락시를 지나는 과정에서 변경된 곳이 있는지 확인하기 위한 엔터티 본문 체크섬

## 메시지는 컨테이너 엔터티는 화물
HTTP 메시지가 운송시스템의 컨테이너라면 HTTP 엔터티는 화물

HTTP1.1의 10가지 주요 엔터티헤더 필드.
|헤더|설명|비고|
|--|--|--|
|Content-Type|엔터티에 의해 전달된 객체의 종류|
|Content-Length|전달되는 메시지의 길이나 크기|
|Content-Language|전달되는 객체와 가장 잘 대응되는 자연어|
|Content-Encoding|객체 데이터에 대해 행해진 변형|
|Content-Location|요청 시점을 기준으로, 객체의 또 다른 위치|
|Content-Range|부분 엔터티라면 이 엔터티가 전체의 어느 부분에 해당하는지 정의|
|Content-MD5|엔터티 본문의 체크섬|
|Last-Modified|서버에서 이 콘텐츠가 생성, 수정된 날|
|Expires|엔터티가 신선하지 않은 것으로 간주되기 시작하는 시각|
|Allow|이 리소스에 대해 어떤 요청 메서드가 허용되는지|
|ETag|인스턴스에 대한 고유 검사기.|엔터티 헤더는 아님
|Cache-Control| 캐시될 수 있는지에 대한 지시자.|''
### 엔터티 본문
엔터티 본문은 가공되지않은 데이터(Content-Encoding 헤더가 있다면 인코딩 되어있는 데이터 일것이고, 그러한 엔터티의 첫 바이트는 인코딩된 내용의 첫 바이트)이다.

>따라서 엔터티 헤더를 통해 데이터의 의미를 설명할 필요가있다.
## Content-Length: 엔터티의 길이
Content-Length 헤더는 메시지의 헨터티 본문의 크기를 `바이트`단위로 나타낸다.

따라서 인코딩에 관계없이 크기를 표시할 수 있다.

Content-Length 헤더는 메시지를 청크 인코딩으로 전송하지 않는 이상 엔터티 본문을 포함 하는 메시지에서는 필수적으로 있어야한다.

Content-Length는 모종의 이유(서버충돌 등)로 인해 메시지가 잘렷는지 감지하고자 할 떄와 지속 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요하다.

### 잘림 검출
이전의 HTTP는 커넥션 닫힘을 보고 메시지가 끝났음을 인지했다.
클라이언트는 Content-Lenght가 없다면 커넥션이 정상적으로 닫힌건지 충돌 등으로 인한것인지 구분하지 못한다.

클라이언트는 메시지 잘림을 검출하기위해 Content-Lenght를 필요로 한다.

프록시는 이에 굉장히 취약한데, 이를 방지하기 위해 캐싱 프록시 서버는 Content-Length 헤더를 지니지 않은 HTTP 본문은 보통 캐싱하지 않음
### 콘텐츠 인코딩
HTTP는 보안 강화나 압축을 통해 공간절약을 할 수 있도록 본문을 인코딩 할 수 있다.

지속 커넥션일 때 인코딩 전의 크기로 보내는것은 심각한 오류를 유발한다!

Content-Lenght는 반드시 인코딩 후의 길이를 보내야한다.
### 엔터티 본문 길이 판별을 위한 규칙.
반드시 순서대로 적용할것.
1. 본문을 가질 수 없는 특정 타입의 HTTP 메시지에서는 Content-Lenght가 무시된다.<br>HEAD 처럼 본문을 갖지 않는 HTTP 메시지에서는 Content-Length 헤더가 무시된다.
2. 메시지가 Transfer-Encoding 헤더를 포함한다면, 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔티티는 '0 바이트 청크'라고 불리는 특별한 패턴으로 끝나야한다.
3. Transfer-Encoding 헤더 필드를 갖는 메시지를 받았다면 반드시 Content-Length 헤더를 무시해야한다.
4. multipart/byteranges타입은 엔터티 길이가 정의되지 않았다면 스스로 크기를 결정할 수 있는 유일한 엔티티 본문 유형이다.
5. 1~4에 해당하지 않는다면, 엔터티는 커넥션이 닫힐 때 끝난다.
6. HTTP/1.0 과의 호환을 위해 HTTP/1.1 요청은 반드시 Content-Lenght 헤더도 가지고 있어야 한다.

## 콘텐츠 인코딩
전송 속도를 줄이기 위해 인코딩을 할 수 있다.
### 콘텐츠 인코딩 과정
1. 웹 서버가 Content-Type과 Content-Length헤더를 수반한 응답 메시지를 생성.
2. 콘텐츠 인코딩 서버(원서버 혹은 다운스트림 프락시)가 인코딩된 메시지 생성, 이 때 Content-Lenght가 달라지며 인코딩 서버는 Content-Encoding에더를 추가하여 디코딩 가능하도록 한다.
3. 수신측은 인코딩된 메시지를 받고 디코딩하여 원본을 얻는다.
### 콘텐츠 인코딩 유형
|콘텐츠 인코딩값|설명|
|--|--|
|gzip|GNU zip 인코딩이 적용되었음을 의미한다.|
|compress|유닉스 파일 압축 프로그램 compress가 실행되었음을 의미한다.|
|deflate| zlib포맷으로 압축되었음을 의미한다.|
|identify|어떠한 인코딩도 수행되지않았다. Content-Encoding 헤더가 없다면 이 값으로 간주|
### Accept-Encoding 헤더
원치않는 방법으로 인코딩 하는것을 알리기위해 Accept-Encoding헤더를 통해 전달한다.

전달하지않으면 모두 ok인것으로 간주한다.
## 전송 인코딩과 청크 인코딩
전송 인코딩은 구조적 이유 때문이지 콘텐츠 포맷과는 독립적이다.

-> 콘텐츠 포멧에 따른 압축법은 이것들의 파일 형태(포맷)에 관련이 깊음.

전송 인코딩이란 메시지 전송을 위한 인코딩.

콘텐츠 인코딩된 응답
```HTTP
HTTP/1.0 200 OK
Content-encoding: gzip
Content-type: text/html
[...]
[encoded message]
```

전송 인코딩된 응답
```HTTP
HTTP/1.1 200 OK
Transfer-encoding: chunked

10
asdfghjk
1
a
```
### 안전한 전송
역사적으로 전송 인코딩은 안전한 전송을 위해 존재했다.

HTTP에서 전송된 메시지 본문이 문제를 일으킬 수 있는 이유중 두 가지
#### 알 수 없는 크기
>어떠한 서버는 동적으로 생성되는 콘텐츠의 크기를 알기 전에 데이터 전송을 시작하려한다.
>
>특별한 꼬리말로 그 끝을 알리려하지만 지속커넥션이 망가지게된다.
#### 보안
공용 전송 네트워크로 메시지를 보내기 전에 전송 인코딩을 사용해 알아보기 어렵게 섞이는 경우가 있다.
### Transfer-Encoding 헤더
전송인코딩을 제어하고 서술하기위한 헤더는 단 두가지이다.
- Transfer-Encoding : 어떤 인코딩이 적용되었는지 수신자에게 알린다.
- TE : 어떤 확장된 전송 인코딩을 사용할 수 있는지 요청헤더에 사용한다.

### 청크 인코딩
청크 인코딩은 메시지를 일정 크기의 여러 청크로 쪼개어 순차적으로 전송한다.

본문이 동적으로 생성됨에 따라 그 중 일부를 버퍼에 담에 보낼 수 있다.

본문을 모두 전송하고나면 크기가 0인 청크를 보내 전송울 완료한다.

## 델타 인코딩
인스턴스란 어느 웹 페이지의 각기 다른 버전

클라이언트가 오래된, 만료된 버전의 문서를 가지고 있다면 최신 인스턴스를 요청할것인데.

변경된 부분이 아주 작은부분이라면? 쓸모없는, 갱신할 필요가 없는 부분도 모두 받아와야할 것이다.

새 페이지 전체를 받아오는 대신 페이지의 일부만 서버가 보내어 받는다면 더 빨리 받아볼 수 있을것이다.

델타 인코딩은 객채 전체가 아닌 변경된 부분만 통신하여 전송량을 최적화하는 HTTP프로토콜의 확장이다.
