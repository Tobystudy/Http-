# 보안 HTTP
이 장에서는 디지털 암호화를 이용해 HTTP트랜잭션을 안전하게 보호하는 더 복잡하고 적극적인 기술을 제시한다.
## HTTP를 안전하게 만들기
HTTP는 안전해야하고, 다음 기술이 필요하다.
- 서버인증 :
- 클라이언트인증
- 무결성
- 암호화
- 효율
- 편재성
- 관리확장성
- 적응성
- 사회적생존성
### HTTPS
HTTP를 안전하게 만드는 방식중 가장 인기 있는 것.
HTTPS를 사용할 때 모든 HTTP요청과 응답 데이터는 암호화되어 네트워크로 보내진다.
HTTPS는 HTTP하부에 보안계층을 제공함으로 작동된다.
이 보안계층은 SSL혹은 TSL을 계승한 전송계층 보안을 이용해 구현된다.
## 디지털 암호학
- 암호 : 텍스트를 아무나 읽지 못하도록 인코딩하는 일고리즘
- 키 : 암호의 동작을 변경하는 매개변수
- 대칭키 암호 체계 : 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- 비대칭키 암호 체계 : 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- 공개키 암호법 : 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- 디지털 서명 : 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 디지털 인증서 : 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보
### 비밀 코드의 기술과 과학
암호법은 누군가 단순히 읽을 수 없도록 하는것 뿐 아니라 변조를 막기위해도 사용할 수 있다.
이는 누군가가 어느 메시지, 트랜잭션의 저자임을 증명하는데에도 사용될 수 있다.
## 대칭키 암호법
- DES
- Triple-DES
- RC2
- RC4
등이 있다,
### 키 길이와 열거 공격
대부분의 경우 인코딩, 디코딩 알고리즘이 공개적으로 알려져있으므로 키를 잘 간수해야한다.
무차별적으로 모든 키값을 대입해보는 공격을 열거 공격(Enumeration Attack)이라고 한다.

향상된 하드웨어의 발전으로 짧은길이의 키는 해킹 가능성이 있기에 조심해야한다.
### 공유키 발급하기
대칭키 암호의 단점은 수신, 발신자 모두 공유키를 가져야한다는것.
대화하는 상대가 총 N명이라면 대략 N^2쌍의 공유키를 필요료하고 기억해야만 한다.
## 공개키 암호법
한 쌍의 호스트가 하나의 인코딩/디코딩 키를 가지는 대신
공개키 암호법은 두 개의 비대칭 키를 사용하는데.
1. 인코딩용 비대칭키(공개 되어있음)
2. 디코딩용 비대칭키(개인이 소유)
이렇게 키를 두 개로 분리하면 인코딩은 모두가, 디코딩은 개인만이 할 수 있어 키쌍의 증가를 줄일 수 있다.
## 디지털 서명
### 서명은 암호 체크섬이다.
디지털 서명은 메시지에 붙어있는 특별한 암호 체크섬, 이는 두 가지 이점을 가진다.
1. 서명은 메시지의 저자를 알려준다.
   저자만이 개인키를 갖기 때문에(훔치지 않았다면), 저자만이 체크섬을 계산할 수 있다. 따라서 개인 서명처럼 동작한다.
2. 서명은 메시지 위조를 방지한다.
   누군가가 송신중인 메시지를 수정했다면 체크섬은 더이상 메시지와 맞지 않게될 것이다.
   체크섬도 개인 키와 연관되어 있기 때문에 올바른 체크섬을 만들어낼 순 없을것이다.
## 디지털 인증서
디지털 인증서란 신뢰할 수 있는 기관으로 부터 보증받은 사용자/회사에 대한 정보를 담고 있다.
### 인증서의 내부
인증 기관에 의해  디지털로서명된 데이터가 들어있다.
일반적으로
- 대상의 이름(사람, 서버, 조직)
- 유효기간
- 인증서 발급자(누가 보증하는지)
- 인증서 발급자의 디지털 서명
을 담고 있다.
### 서버 인증을 위해 인증서 사용하기
사용자가 HTTPS를 통한 웹 트랜잭션을 시작할 때 자동으로 접속한 서버에서 디지털 인증서를 가져오고 해당 인증서가 없다면 보안 커넥션은 실패한다.
서버의 인증서는
- 웹사이트명, 호스트명
- 웹 사이트의 공개키
- 서명 기관의 이름
- 서명 기관의 서명
를 포함하는데
기관이 신뢰할만한 서명기관 이라면 브라우저는 이미 그것의 공개키를 알고 있을것이기에 그 서명을 검증할 수 있다.
서명기관을 모르는 곳이라면 그 서명기관을 신뢰해야 할지 확인할 수 없으므로 사용자에게 해당 기관을 신뢰할지 물어볼것이다.
## HTTPS의 세부사항
### HTTPS 개요
HTTPS는 보안 전송 계층을 통과해 전송되는 HTTP
암호화되지않은 HTTP메시지를 TCP를 통해 전송하기 전에 암호화하는 보안계층 TLS/SSL을 먼저 통과하도록한다.
### HTTPS 스킴
HTTPS프로토콜에서 URL의 점두사는 https

클라이언트는 URL이 http의 스킴을 갖는다면 80으로 연결하고 HTTP명령을 전송한다.
https의 스킴을 갖는다면 443으로 연결하여 서버와 바이너리포맷의 SSL보안 매개변수를 교환하며 핸드셰이크를 하고 암호화된 HTTP명령을 전송한다.

**SSL트래픽은 바이너리 프로토콜이다.**
### 보안 전송 셋업
![image](https://github.com/Tobystudy/Http-Study/assets/41179427/3247a837-b9a2-45d4-84a8-69a1ad411934)


### SSL핸드셰이크
SSL헨드셰이크에서는 다음과 같은 일들이 일어난다.
- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기위한 임시 세션 키 생성

![image](https://github.com/Tobystudy/Http-Study/assets/41179427/16c3e665-90ee-4b91-bd1a-34e3aabf42d2)

### 서버 인증서
- SSL은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날라 주는 상호 인증을 지원하지만 오늘날 클라이언트 인증서는 웹 브라우징에선 흔히 쓰이지 않는다.
## 프락시를 통한 보안 트래픽 터널링
클라이언트가 서버로 보낼 데이터를 서버의 공개키로 암호화하기 시작했다면, 프락시는 더 이상 HTTP 헤더를 읽을 수 없다.
그리고 만약 HTTP 헤더를 읽을 수 없다면, 프락시는 요청을 어디로 보내야 할는지 알 수 없게 된다.
이 떄 프락시와도 잘 동작할 수 있게 하기위한 기법중 하나가 HTTPS SSL 터널링 프로토콜이다.
HTTPS 터널링 프로토콜을 이용해 클라이언트는 프락시에게 연결하고자하는 안전한 호스트를 평문으로 말해준다.
HTTP는 CONNECT라는 새로운 확장 메서드를 이용해 평문으로된 종단정보를 전송한다.
CONNECT 메서드는 프락시에게 희망하는 호스트와 포트번호를 연결해달라고 요청해 서버와 클라이언트 사이에서 데이터를 직접 오갈수 있게 해주는 터널을 만든다.
