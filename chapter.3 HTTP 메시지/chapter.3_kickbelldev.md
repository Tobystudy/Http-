# 3장 HTTP 메시지

## 메시지의 흐름

- 인바운드: 서버 방향으로 흐르는 것
- 아웃바운드: 클라이언트 방향으로 흐르는 것

- 업스트림: 메시지의 발송자
- 다운스트림: 메시지의 수신자

## 메시지의 각 부분

HTTP 메시지는 단순하고 구조화된 데이터 블록.

```http
HTTP/1.0 200 OK //시작줄
Content-type: text/plain
Content-length: 19 //헤더

Hi! I'm a message! //본문
```

### 메시지 문법

요청 메시지

```
<메서드> <요청 URL> <버전>
<헤더>

<본문>
```

응답 메시지

```
<버전> <상태 코드> <사유 구절>
<헤더>

<본문>
```

- 메서드: 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작
- 요청 URL: 리소스를 지칭하는 완전한 URL 혹은 PATH 요소
- 버전: 메시지에서 사용중인 HTTP 버전
- 상태 코드: 요청에 대해 어떤 일이 일어났는지 설명하는 세 자리 숫자
- 사유 구절: 상태 코드를 사람이 이해할 수 있도록 설명해주는 짧은 문구
- 헤더: 메시지에 대한 부가적인 정보들
- 본문: 선택적인 임의의 데이터 블록

### 시작줄

모든 HTTP 메시지는 시작줄로 시작.\
요청의 시작줄은 무엇을 해야하는지 말해주고,\
응답의 시작줄은 무슨 일이 일어났는지 말해줌.

## 메서드

| 메서드  | 설명                                     | 본문여부 |
| ------- | ---------------------------------------- | -------- |
| GET     | 서버에서 문서 가져오기                   | X        |
| HEAD    | 문서에 대해 헤더 가져오기                | X        |
| POST    | 서버가 처리해야할 데이터 보내기          | O        |
| PUT     | 서버에 요청 메시지 본문 저장             | O        |
| TRACE   | 메시지가 서버에 도달하는 과정 추적       | X        |
| OPTIONS | 서버가 어떤 메서드를 받을 수 있는지 확인 | X        |
| DELETE  | 서버에서 문서를 제거                     | X        |

HTTP 명세에 정의되지 않은 확장 메서드들도 있음. (ex: RESTful의 `PATCH`메서드)

### Safe Method

`GET`과 `HEAD`메서드는 요청의 결과로 서버에 어떤 작용도 없어서 안전하다 할 수 있음. (보장되는 것은 아님)

### GET

가장 흔히 쓰이는 메서드. 서버에게 리소스를 달라고 요청함.

### HEAD

정확히 GET처럼 행동하지만, 본문 없이 헤더만 반환함.

- 리소스를 가져오지 않더라도 어떤 리소스인지 알 수 있음.
- 상태 코드를 확인하여 객체가 존재하는지 확인.
- 헤더를 확인하여 리소스 변경 여부 검사.

### PUT

요청의 본문을 가지고 문서 전체를 변경(또는 추가) 하는 메서드.

이 메서드의 한계로 인해 RESTful 아키텍처에선 `PATCH`메서드를 추가했음.

### POST

입력된 데이터를 서버에 전송하기 위해 설계된 메서드.

### TRACE

클라이언트의 요청 메시지가 서버에서 루프백으로 응답으로 되돌려지는 메서드.

클라이언트가 요청을 할 때 방화벽, 프록시, 게이트웨이 등을 지날 수 있음. \
클라이언트와 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가며 변경사항을 확인.

### OPTIONS

해당 리소스에 대해 어떤 메서드들이 지원되는지 알아보기 위한 메서드.

### DELETE

지정한 리소스를 삭제하는 것.

## 상태 코드

- `100-199`: 정보
- `200-299`: 성공
- `300-399`: 리다이렉션
- `400-499`: 클라이언트 에러
- `500-599`: 서버 에러

### 100번대

- `100 Continue`: 최적화를 위한 상태 코드. \
  클라이언트가 큰 데이터를 보낼 때 요청이 가능한지 확인해줄 용도로 주로 사용됨. \
  `Expect: 100-continue` 헤더를 같이 보내면 서버가 이 상태 코드로 응답해줌. \
  그 이후 실제 본문 데이터를 전송함.

### 200번대

요청이 성공했음을 알리는 상태 코드 대역.

- `200 OK`: 요청이 정상이고, 본문에 요청된 리소스를 가지고 있음.
- `201 Created`: 객체 생성 요청에 대한 응답. 생성된 객체의 구체적인 참조가 담긴 Location을 헤더로 포함해야함.
- `202 Accepted`: 요청은 받아들여졌으나 아직 어떤 동작도 수행하지 않았음을 나타냄.
- `203 Non-Authoritative Information`: 원래 서버가 아닌 리소스의 사본(중개자가 가지고 있는)에서 왔을 경우.
- `204 No Content`: 응답 본문이 없을 때.
- `205 Reset Content`: HTML 폼에 채워진 값을 비우라는 의미.
- `206 Partial Content`: 문서의 부분 또는 특정 범위를 요청한 것이 성공했음.

### 300번대

클라이언트가 찾는 리소스의 대안 응답을 주거나, 리소스가 옮겨진 위치 등을 가지고 있음을 알리는 상태 코드들.

일부는 캐시 유효성을 확인하기 위해 사용된다. (`304 Not Modified` 등)

302와 303, 307 코드가 비슷한 의미로 정의되어 있는데, HTTP/1.0과 HTTP/1.1이 상태코드를 다루는 방식의 차이 때문.

### 400번대

클라이언트가 잘못함.

- `400 Bad Request`: 포괄적인 의미의 클라이언트 에러 상태 코드.
- `401 Unauthorized`: 클라이언트가 인증되지 않음.
- `403 Forbidden`: 요청이 서버에 의해 거부되었음.
- `404 Not Found`: 요청한 URL을 찾을 수 없음.
- `405 Method Not Allowed`: 서버가 지원하지 않는 메서드로 요청을 받았을 때.
- `406 Not Acceptable`: 클라이언트가 받을 수 없는 미디어 타입의 리소스일 경우.
- `408 Request Timeout`: 요청을 수행하는데 너무 오랜 시간이 걸릴 경우 서버는 이 상태 코드를 내려주고 연결을 끊을 수 있음.
- `409 Conflict`: 요청이 리소스에 대해 일으킬 수 있는 충돌들을 지칭.
- `410 Gone`: 서버가 한때 갖고있었으나 없어진 리소스에 대해 요청받았을 경우.
- `411 Length Required`: 요청 메시지에 Content-Length 헤더가 있을 것을 요구할 때.
- `412 Precondition Failed`: 조건부 요청 중 일부가 실패했을 때.
- `413 Request Entity Too Large`: 요청의 크기가 너무 클 때.
- `414 Request URI Too Long`: 서버가 처리할 수 있는 한계를 넘은 길이의 URI가 들어왔을 때.
- `415 Unsupported Media Type`: 서버가 처리할 수 없는 미디어 타입일 경우.
- `416 Requested Range Not Satisfiable`: 리소스의 특정 범위를 요청했을 때에 범위가 잘못되었을 경우.
- `417 Expectation Failed`: 요청에 포함된 Expect 헤더에 서버가 해줄 수 없는 기대가 담겨있는 경우.

### 500번대

서버에서 에러 발생 시.

- `500 Internal Server Error`: 범용 서버 에러 코드.
- `501 Not Implemented`: 서버가 할 수 없는 일을 요청했을 때.
- `502 Bad Gateway`: 프록시 혹은 게이트웨이가 다음 링크로부터 가짜 응답을 맞이했을 경우.
- `503 Service Unavailable`: 서버가 현재 먹통임. 나중에 다시 요청해달라는 의미.
- `504 Gateway Timeout`: 408과 비슷하지만 서버가 아닌 게이트웨이/프록시 등이 내려주는 상태 코드.
- `505 HTTP Version Not Supported`: 서버가 지원하지 않는 버전의 프로토콜로 요청받았을 경우.

## 헤더

메시지에 대한 부가 정보들로, 클라이언트/서버가 어떤 것을 해야할 지 결정하기 위해 사용됨.

- 일반 헤더: 다양한 목적으로 사용되는 일반적인 헤더 (예: Date 헤더)
- 요청 헤더: 요청 메시지에 들어있는 헤더
- 응답 헤더: 응답 메시지에서 클라이언트에 정보를 제공하기 위한 헤더
- 엔티티 헤더: 본문의 데이터에 대한 헤더
- 확장 헤더: 비표준 헤더

### 일반 헤더

- Connection: 클라이언트/서버가 요청/응답 연결에 대한 옵션을 정할 수 있게 해줌
- Date: 메시지가 만들어진 일시
- MIME-Version: 발송자가 사용한 MINE의 버전
- Trailer chunked transfer: 인코딩된 메시지 끝 부분에 위치한 헤더의 목록
- Transfer-Encoding: 메시지에 적용된 인코딩
- Upgrade: 발송자가 원하는 업그레이드된 버전/프로토콜
- Via: 어떤 중개자를 거쳐왔는지 알려줌

### 일반 캐시 헤더

- Cache-Control: 메시지의 캐시 지시자
- Pragma: 메시지와 함께 지시자를 전달하는 방법 (캐시에 국한되지 않음)

### 요청 헤더

- Client-IP: 클라이언트의 IP
- Host: 요청의 대상이 되는 서버의 호스트, 포트
- Referer: 현재 요청이 들어있던 문서의 주소 (Referrer의 오타임)

#### Accept 헤더

클라이언트가 선호하는 것이나 처리할 수 있는 능력을 명시

#### 조건부 요청 헤더

- Expect: 요청에 필요한 서버의 행동
- Range: 리소스의 특정 범위 요청

#### 요청 보안 헤더

HTTP 자체적으로 가지는 간단한 인증 요구/응답 체계에 사용되는 헤더들

- Authorization: 클라이언트가 서버에 전송하는 인증 그 자체에 대한 정보
- Cookie: 클라이언트가 서버에 토큰을 전달할 때 사용
- Cookie2: 쿠키의 버전

#### 프록시 요청 헤더

- Max-Forwards: 요청이 서버로 향하는 과정에서 다른 중개자를 몇 번 거칠 수 있나를 지정

### 응답 헤더

응답에 대한 부가정보들

- Age: 응답이 얼마나 오래되었는지 (프록시 캐시를 통한 응답)
- Retry-After: 현재 리소스가 사용 불가능할 때, 언제 사용 가능하게 되는지
- Server: 서버 애플리케이션의 이름, 버전
- Warning: 사유 구절보다 자세한 경고 메시지

#### 응답 보안 헤더

- Proxy-Authenticate: 프록시에서 클라이언트로 보낸 인증 요구의 목록
- Set-Cookie: 서버가 클라이언트 측에 토큰을 설정하기 위해 사용 (쿠키 세팅)

### 엔티티 헤더

수신자에게 송신자가 다루는 데이터가 어떤 데이터인지 알려주는 헤더들

#### 엔티티 캐싱 헤더

- ETag: 엔티티 태그
- Expires: 엔티티가 유효하지 않아 원본을 다시 받아와야 하는 일시
- Last-Modified: 엔티티의 가장 최근 변경 일시
