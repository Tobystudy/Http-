# 7장 캐시

웹 캐시는 문서의 사본을 자동으로 저장하는 HTTP 장치다.

웹 요청이 캐시에 도착했을 때 캐시된 사본이 존재한다면 그 문서는 캐시로부터 제공된다.

## 캐시의 장점

- 불필요한 데이터 전송을 줄임.
- 네트워크 대역폭 병목을 줄여줌.
- 원 서버에 대한 요청을 줄여줌.
- 네트워크 거리 지연을 줄여줌.

### 불필요한 데이터 전송

원 서버가 중복해서 트래픽을 주고받는 낭비가 줄어든다.

### 대역폭 병목

클라이언트가 서버에 접근할 때의 속도는 그 경로에 있는 가장 느린 네트워크의 속도와 같음.

느린 네트워크를 지나지 않는 앞단에 캐시를 두면 서버까지 접근하는 것 보다 빠르게 문서를 가져올 수 있음.

### 갑작스런 요청 쇄도

캐시를 두지 않으면 원 서버에 갑작스럽게 많은 요청이 몰렸을 때 서버 부하 때문에 큰 문제가 된다.

### 네트워크 거리 지연

빛의 속도 그 자체가 유의미한 지연을 유발하므로 가까운 곳에 캐시를 두면 이득이 된다.

### 캐시 히트/미스(적중/부적중)

캐시에 요청이 도달했을 때 문서가 있으면 히트/없으면 미스

### 재검사(Revalidation)

웹 컨텐츠는 변경될 수 있기 때문에 캐시는 반드시 문서가 여전히 최신인지를 확인해야 한다.

이런 '신선도 검사'를 HTTP 재검사라고 부른다.

캐시는 재검사가 필요할 때 작은 재검사 요청을 보내고, 컨텐츠가 변경되지 않았다면 원 서버는 아주 작은 304 응답 메시지를 보낸다.

이는 재검사 적중 또는 느린 적중이라고 부르는데,\
원 서버에 캐시가 유효한지 확인하는 과정이 있기 때문에 일반적인 캐시 적중보다 느리기 때문.\
부적중보단 빠름.

`If-Modified-Since` 헤더: 표시된 시간 이후에 컨텐츠가 변경된 경우에 문서를 보내달라는 의미의 헤더.

#### 재검사 부적중

원 서버의 문서가 캐시와 다르다면 컨텐츠 전체와 함께 200 응답을 준다.

만약 문서가 삭제되었다면 404 응답을 준다.

### 적중률

캐시가 문서를 처리하는 비율을 캐시 적중률이라고 한다.

0에서 1까지 (비율) 표시되고 0은 모든 요청이 부적중한 것, 1은 모든 요청이 적중했음을 의미.

#### 바이트 적중률

문서가 모두 같은 크기가 아니므로 데이터 크기로 적중률을 매기는 것. 트래픽 관점에서 유의미.

#### 적중과 부적중의 구별

응답이 캐시 적중이었는지 부적중이었는지 클라이언트는 알지 못한다고 한다.

Date헤더, Age헤더 등으로 대략적으로 표현할 순 있지만 정확하지 않음.

## 캐시 토폴로지

개인 전용 캐시 -> 한 명의 사용자에게만 유효한 캐시, 대부분의 브라우저는 자주 쓰이는 문서를 캐시한다.
공용 캐시 -> 여러 사용자가 자주 쓰는 페이지를 캐시, 캐시 프록시 서버로 불린다.

### 캐시 레이어

작은 캐시에서 부적중 시 더 큰 부모 캐시가 그걸 처리하도록 하는 계층형 캐시가 합리적인 경우가 많다.

### 캐시망

단순한 캐시 레이어보다 복잡한 캐시망을 만드는 경우가 많다.

- URL에 근거하여 부모 캐시와 원 서버 중 하나를 동적으로 선택.
- URL에 근거하여 특정 부모 캐시를 동적으로 선택.
- 부모 캐시에게 가기 전에 캐시된 문서를 로컬에서 찾아봄.
- 다른 캐시 프록시들이 그들의 캐시된 컨텐츠에 부분적으로 접근할 수 있도록 허용하되, 인터넷 트랜짓은 허용하지 않음.

선택적인 피어링을 지원하는 캐시는 형제 캐시라고 불린다.

인터넷 캐시 프로토콜(ICP) 혹은 하이퍼텍스트 캐시 프로토콜(HTCP)와 같이 HTTP를 확장하여 사용한다.

## 캐시 처리

캐시 프록시가 HTTP GET 요청 메시지 하나를 처리하는 과정.

### 1. 요청 받기

요청 데이터를 읽는다.

### 2. 파싱

요청 메시지를 여러 부분으로 파싱하여 헤더를 조작하기 쉬운 자료구조에 담는다.

### 3. 검색

URL을 알아내고 캐시된 문서가 있는지 검사.

캐시된 문서가 없으면 부모 캐시/원 서버 등에 요청을 보낸다.

원 서버 응답 자체를 캐싱하고 있으므로 캐시가 적중되는 동안 올바른 서버 헤더가 반환될 수 있음.

캐시 객체는 얼마나 오랫동안 캐시되었는지, 얼마나 자주 사용되었는지와 같은 정보를 지닐 수 있음.

### 4. 신선도 검사

'신선하지 않은' 캐시된 문서를 발견했다면, 제공하기 전에 원 서버에 캐시 재검사를 해야한다.

### 5. 응답 생성

캐시 응답은 원 서버에서 온 것 처럼 보여야 하기 때문에 적절히 가공된다.

하지만 캐시가 Date 헤더를 조정하면 안된다.

### 6. 전송

응답을 클라이언트에 돌려준다.

### 7. 로깅

캐시 사용에 대한 통계, 로그를 남긴다.

## 캐시 신선하게 유지하기

### 문서 만료

- `Cache-Control` 헤더: 캐싱 동작을 지정하는 헤더
  - `max-age` 속성: 문서의 최대 나이를 지정(초 단위)
- `Expires` 헤더: 절대적인 유효기간을 명시

이를 통해 만료 여부를 알 수 있고, 만료되면 새로운 문서를 얻어와야 한다.

### 만료 시 서버 재검사

캐시 만료가 캐시된 문서가 원 서버에 존재하는 문서가 다르다는 뜻은 아니다. 단지 검사할 시간이 되었다는 것.

재검사 결과

- 컨텐츠 변경 시: 새로운 문서를 가져와 캐싱.
- 컨텐츠 비변경: 새 만료일과 헤더들만 가져와서 캐시 갱신.

### 조건부 메서드와 재검사

조건부 요청 헤더

- `If-Modified-Since: <date>`: 주어진 날짜 이후로 문서가 수정되었다면 요청 메서드 처리.
  - 이 헤더를 쓰는 요청은 흔히 IMS 요청으로 불림.
  - 문서가 여기 쓰여진 날짜 이후에 변경되었다면, GET 요청 평범하게 성공.
  - 변경되지 않았다면 304 상태코드와 함께 변경되어야 할 응답 헤더들을 제공.
  - 서버는 마지막 수정된 날짜가 담긴 `Last-Modified` 헤더를 보내주고 그걸 `If-Modified-Since`에 담아서 보낸 후 원 서버에서 비교하는 것.
- `If-None-Match: <tag>`: 캐시된 문서와 원 서버 문서가 문서의 일련번호와 같이 동작하는 `ETag`가 다를 경우에 요청 메서드 처리.
  - 여러 개의 ETag를 포함할 수 있다.
  - 태그에 `W/`를 붙이면 약한 검사를 한다.

#### 언제 `ETag`? 언제 `Last-Modified`?

- 서버가 ETag를 반환했다면 반드시 ETag 검사기를 사용해야함.
- Last-Modified 만을 반환했다면 IMS 검사.
- 모두 사용할 수 있다면 둘 다 검사.

## 캐시 제어

서버가 캐시를 제어할 수 있는 여러 방법을 제공.

`Cache-Control` 헤더

- `no-store`: 캐시가 사본 문서를 만드는 것을 금지.
- `no-cache`: 문서를 저장하는것 까진 허용, 재검사 하지 않으면 제공 불가.
- `must-revalidate`: 반드시 만료 정보를 따르고 신선도 체크를 하도록 지시.
- `max-age`: 문서가 서버로부터 온 이후 흐른 시간. 0으로 설정하면 캐시/리프레시하지 않도록 지시하는 것.

- `Expires` 헤더: 실제 만료 날자를 지정.
- 캐시가 알아서 하도록

### 클라이언트 신선도 제약

클라이언트 또한 `Cache-Control`을 요청 헤더에 넣어서 캐시에게 만료 제약을 할 수 있다.

- `max-stale`: 신선하지 않은 문서라도 자유롭게 제공. <느슨>
- `max-stale=<s>`: 만료시간이 매개변수만큼 지난 문서도 받는다. <느슨>
- `min-fresh=<s>`: 지금으로부터 적어도 `<s>`초 후까지 신선한 문서만을 받아들임. <엄격>
- `max-age=<s>`: 캐시는 `<s>`초보다 오래 캐시된 문서를 반환할 수 없음. <더 엄격>
- `no-cache`: 캐시된 문서를 재검사해서 받을 것.
- `no-store`: 캐시된 문서를 삭제해달라.
- `only-if-cached`: 캐시된 문서만을 받겠다.

## 캐시 제어 설정

## 캐시와 광고

광고의 횟수 등으로 돈을 버는 컨텐츠 제공자들은 캐시를 무력화할 필요가 있다.
