# 캐싱이 필요한 상황들
- 불필요한 데이터 전송이 잦을때
- 대역폭 병목이 존재할때 : 물리적인 대역폭 병목등
- 갑작스런 요청이 쇄도할때 : 트래픽 급증
- 거리로 인한 지연
  - 빛의 속도는 초속 30만 km
  - 미국 보스턴과 서울간 거리는 대략 11000킬로미터로 요청과 응답의 기본 지연은 120ms에 달함
  - aws 서울에 서버가 있고 미국에서 접근시 모든 요청의 기본 지연이 0.12초인 셈

# 캐시 히트에 관해
## 재검사(Revalidation)
- 신선도 검사라고도 부름
- 변경 여부를 체크하고 변경되지 않을경우 304 Not Modified 응답을 기대 == 느린 캐시 적중
> If-Modified-Since 헤더를 사용
- 재검사시 업데이트가 필요하다면 정상적인 응답과 함께 200 응답
- 삭제시 404
=> 위와같은 동작을 위해서는 서버는 캐시의 Revalidation에 대해 구현이 필요하다

## 히트 메트릭 / 캐시 성능 측정법

### 적중률
- 높을수록 당연 좋다
### 바이트 적중률
- 데이터 사이즈로 적중률을 구하는게 더 나을수도
### 적중과 부적중의 구별은 어떻게?
- 응답의 Age 헤더? Date 헤더? 너무 대략적인거 아닌가?
- 그보단 캐시 구현체 자체가 캐시 히트 여부를 판단해 메트릭을 발행하는게 더 맞는 동작같다.

# 캐시 토폴로지

## 계층화된 캐시 레이어 만들기

- 작은 캐시에서 캐시 부적중시 더 큰부모 캐시가 그 걸러 남겨진 트래픽을 처리하도록 하는 계층 방식
- 1차 캐시 2차캐시도 같은 개념이지만 백엔드개발자 입장에서 캐시는 보통 디비의 부하를 줄이는 용도인데 반해, 현 책의 접근법은 프록시캐시로 서버자체의 트래픽을 줄이는 용도
- 복잡한 캐시망의 경우 ICP(Internet Cache Protocol), HTCP(Hyper Text Cache Protocol)등을 이용

# 캐싱 처리 기본 플로우

## 1. 요청받기
## 2. 파싱
- 메시지 파싱, url, 헤더 추출 등
## 3. 검색
- 웹 프록시 캐시의 경우 원서버 응답 자체를 캐싱하고 있으므로, 캐시 적중동안 올바른 서버 헤더가 반환 될 수 있음

## 4. 신선도 검사
- 보통은 필수적인 체크보다는 기본적인 ttl이 존재

## 5. 응답 생성
- 캐시가 Date 헤더를 조작하면 안됨! 원본 응답 헤더 Date는 그대로 써야한다 -> 이걸 통해 캐시 히트를 간접접으로 클라이언트가 추론할 수 있음

## 6. 전송
## 7. 로깅
- 메트릭 수집을 위해서라도 필요

# 신선한 캐시 유지법
## 문서 만료
- Cache-Control, Expires : 컨텐츠가 얼마동안 신선한 상태인지를 명시

![uploaded image](https://github.com/jinia91/blogBackUp/blob/main/img/239504687231008?raw=true)

- max-age는 초단위
- expires는 절대 유효기간

서버가 내려주고 캐시는 이걸 기준으로 유효기간을 가진다고 보면됨

## 문서만료시 서버 재검사
- 만료시 burst 전략도 있지만, 단순 재검사만 해도 되긴함
- 이경우는 서버가 해당 체크 헨들링이 구현되있어야함

### 조건부 메서드와 재검사
- '조건부 GET'
- 보통 헤더 커스텀으로
- 앞서 본것처럼 If-Modified-Since: date
- IMS 요청이라고도 표현
- 날짜를 진짜로 체크하기보단, 수정일의 문자열 비교만으로 쉽게 확인가능
- 틀리면 일단 이상한거다
- 혹은 엔티티 태그로 버저닝을 명시할수도 있음 "If-None-Match: "v2.7""
- 만약 여러 검증이 있을경우엔 or 연산이 아니라 And 연산으로 적용해야함

# 서버의 캐시제어
- 서버가 캐시컨트롤로서 값을 내려 캐시가 어떻게 동작하도록 유도하는것

## no-store
- 사본 금지
## no-cache
- revalidation 필수
- 이름이랑 다르다. 매번 revalidation 하라는 의미
## Max-age, Expires
## Must-Revalidate
- 만료시 신선도 체크를 꼭 하라는 의미
- no-cache랑 헤깔리지말자

> 서버가 제어를 안하더라도 캐시는 휴리스틱하게 만료 제어를 꼭 구축해야한다!

## max-stale
- 신선하지 않아도 캐시 제공 가능

## min-fresh
- 캐시신선도 엄격 관리

# 광고 카운팅과 캐시
- 실제 카운팅이 중요한 비즈니스 모델에서 캐시가 있다면? : 캐시 무력화가 필요하다

## 방법 1: 광고 url 매번 재발급하기
  - 개발시 웹페이지 캐시문제때문에 무력화하는것과 비슷한느낌
  - 캐시를 강제 무력화
  - 무식하지만, 가장 확실하고 변조 위험도 없다
## 방법 2: 매번 재검사하기
- 약간의 트래픽 추가는 있지만 그나마 현실적
## 방법 3: 로그 마이그레이션
- 이상적으론 트래픽은 줄고 캐시히트로 감사하는것이 더 기술적으로 맞는 방식
- 하지만 변조문제와 인증, 마이그레이션 비용등의 현실적인 문제가...
## 방법 4: 메트릭으로 반환
- 위보단 당연 낫지만, 변조위험은? 메트릭은 신뢰할수 있나?
  
