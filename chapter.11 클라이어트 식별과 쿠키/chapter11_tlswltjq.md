# 클라이언트 식별과 쿠키
웹 서버는 서로 다른 수천개의 클라이언트들과 동시에 통신한다.
서버는 요청을 처리할 뿐만아니라 클라이언트를 추격해야할 수도 있다.
HTTP는 무상태 프로토콜. 웹 사이트는 개인화된 서비스를 제공하기위해 약간의 정보를 이용해 요청의 사용자를 식별한다.
이 장에서는 다음과 같은 사용자 식별 기술을 논의한다.
- 사용자 식별 관련 정보를 전달하는 HTTP헤더들
- 클라이언트 IP 주소 추적으로 알아낸 IP주소로 사용자를 식별
- 사용자 로그인 인증을 통한 사용자 식별
- URL에 식별자를 포함하는 기술인 FatURL
- 식별 정보를 지속해서 유지하는 강력하면서도 효율적인 기술인 쿠키
## HTTP헤더
**From**
- 메시지를 보낸 사용자의 이메일 주소
**User-Agent**
- 클라이언트 소프트웨어의 식별자
**Referer**
- 현재 요청이 발생한 웹 페이지의 URL
**Authorization**
- 클라이언트가 서버에 자신의 신원을 인증하는데 사용
**Client-ip**
- 클라이언트의 원격 IP를 식별하는데 사용
**X-Forwarded-For**
- 클라이언트의 원격 IP를 식별하는데 사용
**Cookie**
- 클라이언트와 서버가 사이에 세션 상태를 유지하고 사용자를 식별하기위해 사용
## 뚱뚱한 URL
상태정보를 URL에 추가, 확장해나가며 동적으로 생성해 나가는 방식.

#### 단점
- 못생긴 URL
- 공유하지 못하는 URL
  : 세션에대한 정보를 담고있기때문에 개인정보를 공유하게될 수 있음.
- 캐시를 사용할 수 없음
  : URL이 달라짐 -> 기존 캐시에 접근할 수 없다.
- 서버 부하 가중
  : 매번 세션정보에 따라 화면을 새롭게 그려야한다.
- 이탈
  : 사전에 세션정보 추가한 링크만을 이용해야 뚱뚱한URL이 문제없이 작동하지만, 해당 세션에서 이탈하기 매우 쉽다.
- 세션간 지속성의 부재
  : 로그아웃하면 모든 정보를 잃게됨.
## 쿠키
현재 널리 이용되는 방식.
쿠키와 캐시의 충돌 가능?
### 쿠키의 타입
- 세션쿠키(Session Cookie)
- 지속쿠키(Persistent Cookie)
두 쿠키의 차이점은 파기되는 시점, 지속 쿠키는 브라우저를 닫거나 컴퓨터를 재시작해도 유지된다.
Expires, Max-Age 파라미터를 통해 지속 쿠키를 관리한다.
### 쿠키의 동작방식
이름 = 값 형태의 리스트를 가지고 Set-Cookie / Set-Cookie2 와 같은 HTTP확장 헤더에 기술되어 사용자에게 전달한다.
#### Domain 속성
쿠키는 생성한 서버에게만 해당 쿠키에 담긴 정보를 전달해 잠재적인 문제(필요하지않은 정보 전달, 성능저하, 개인정보 문제)를 방지한다.
서버가 쿠키를 생성할 때 Set-cookie응답 헤더에 Domain속성을 기술해 특정 도메인을 가지고있는 사이트에 접근시 항상 전달할 수 있다.
```HTTP
Set-cookie: user="mary17"; domain="airtrabelbargains.com"
```
#### Path 속성
쿠키가 전송될 수 있는 경로를 저장한다.
```HTTP
Set-cookie: perf=compact; domain="airtrabelbargains.com"; path=/autos/
```
[Set-Cookie와 Cookie가 정의 된 문서](https://datatracker.ietf.org/doc/html/rfc6265#section-5.2)
### 쿠키와 캐싱
쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 이전 사용자의 쿠키가 다른 사용자에게 할당 되거나 개인정보가 노출되는 문제가 발생할 수 있다.
#### 캐시를 다루는 원칙
- Cache-Control를 명시해 문서를 캐시할지 안할지 명시해주자.
- Set-Cookie헤더를 캐시하는것을 유의하자, 사용자 추적을 실패할 수 있다.
