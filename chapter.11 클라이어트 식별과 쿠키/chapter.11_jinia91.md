# HTTP의 무식별성 개요
- 기본적으로 http 요청은 비식별성
- 추가적인 정보에 의존해야한다
- 하지만 개인화된 서비스 제공을 위해서는 식별이 필수
  - 맞춤 추천
  - 저장된 사용자 정보 재사용
  - 세션 추적

# 식별방법들
## HTTP 헤더 사용
|헤더이름|헤더타입|설명|
|-|-|-|
|From|요청|사용자의 이메일 주소|
|User-Agent|요청|사용자의 브라우저|
|Referer|요청|사용자가 현재 링크를 타고온 근원 페이지|
|Authorization|요청|사용자 이름과 비밀번호|
|Client-ip|확장|클라이언트의 IP 주소|
|X-Forwarded-For|확장|클랑언트의 ip 주소|
|Cookie|확장|서버가 생성한 ID 라벨|

- from : 이상적이지만 불필요한 수집을 우려해 잘 사용되지 않음, 실제론 봇이 쓰는경우가 많다
- user-agent : 브라우저 정보일 뿐이라 특정 사용자 식별로 사용되기는 어렵다
- Referer : 특정 경로 의존성에 대한 정보 데이터를 수집하긴 좋지만 식별에 쓰이긴 어렵다
### ip 기반
- 클라이언트 IP 주소는 사용자가 아닌 컴퓨터를 가리키므로 정확한 식별로 보기 어렵다
- ISP는 동적 ip 할당도 많이 사용하므로 특정성이 더 어렵다
- 방화벽이나 ip 변조문제는?
- ip는 한계가 많다

### 사용자 로그인
- 401 UnAuthorized로 로그인 유도
- 우리가 흔히 생각하는 기본적인 Authorization 방식 인증
### 뚱뚱한 URL
- url에 모든 식별정보를 담아 요청시마다 식별하게 하는방식
- 특정 요청 id를 담아 쿼리스트링으로 식별하는 식으로 은근히 자주 사용된다
- 문제는 못생긴 URL 형태
- 정보 유출 문제
- 브라우저 캐시 사용을 못하는 문제
- 서버 부하
- 이탈이 쉬움
- 세션 지속의 아쉬움

### 쿠키
- 가장 널리 사용되는 방식 중 하나
#### 타입
- 세션 쿠키 : 브라우저를 닫으면 삭제
- 지속 쿠키 : 디스크에 저장되어 브라우저를 닫거나 컴퓨터를 재시작해도 남아있음
- discard, expired, max-age 등이 없다면 기본 세션쿠키

#### 어떻게 동작하는가 
- 서버가 사용자에게 붙이는 스티커같은 개념
- 기본적인 발상은 브라우저가 서버관련 정보를 저장하고 사용자가 해당 서버에 접근할 떄마다 그 정보를 함께 전송하게 하는것
- 클라이언트측 상태로 정의할 수 있음
- 쿠키 명세의 공식적인 이름이 HTTP 상태 관리 체계!

#### 구글 크롬 쿠키
- 크롬은 SQL Lite 파일로 쿠키를 관리
- 필드는 총 13개
- creation_utc, host_key, name, value, path, exprire_utc, secure 등

<img width="1110" alt="image" src="https://github.com/Tobystudy/Http-Study/assets/85499582/40398fae-0c7f-447f-98f1-3c3ef1c5623b">

- 실제로 SQL Lite 뷰어로 까볼수있다

#### 사이트마다 다른 쿠키를 보낸다
- 모두 전달한다면 성능 문제
- 대부분이 무의미한 값일것
- 도메인 경로 기준으로 생성된 쿠키만 보낸다.
- Domain 속성!

<img width="872" alt="image" src="https://github.com/Tobystudy/Http-Study/assets/85499582/40e1f997-dd95-4a5b-956c-55395bfb5f8d">


#### 쿠키 구성요소

- 이름 = 값
- Expires
- Domain
- Path
- Secure
- Max-Age
- port
- discard

#### 쿠키와 캐싱
- 캐시 되지 말아야할것은 명시해라(Cache-Control:no-cache)
- set-cookie 자체를 캐시하는 상황을 주의하라

#### 보안문제가 되는 오용
- 협력업체 웹 사이트가 사용자를 추적하려고 지속쿠키를 사용하는 방식

